import org.emftext.language.java.classifiers.ConcreteClassifier
import tools.vitruv.applications.pcmjava.util.java2pcm.TypeReferenceCorrespondenceHelper

import static tools.vitruv.applications.pcmjava.util.java2pcm.TypeReferenceCorrespondenceHelper.*
import static tools.vitruv.applications.util.temporary.java.JavaTypeUtil.*

import static extension edu.kit.ipd.sdq.commons.util.org.palladiosimulator.pcm.repository.ParameterUtil.*
import org.emftext.language.java.members.Field
import org.palladiosimulator.pcm.repository.RepositoryPackage
import org.palladiosimulator.pcm.repository.CompositeDataType

import "http://www.emftext.org/java" as java 
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm


reactions: classifierBody
in reaction to changes in AdjustedJava
execute actions in PCM


reaction MemberRenamed {
	after attribute replaced at java::Member[name]
		with !(affectedEObject instanceof ConcreteClassifier) && !(affectedEObject instanceof Field)
	call {
		renameMember(affectedEObject)
	}
}

routine renameMember(java::Member javaMember) {
	match {
		val pcmElement = retrieve pcm::NamedElement corresponding to javaMember}
	action {
		update pcmElement {
			pcmElement.entityName = javaMember.name
		}
	}
}

reaction ParameterCreated {
	after element java::OrdinaryParameter inserted in java::Parametrizable[parameters]
	call {
		createParameter(newValue, affectedEObject)
	}
}

routine createParameter(java::OrdinaryParameter javaParameter, java::Parametrizable javaMethod) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to javaMethod
	}
	action {
		val pcmParameter = create pcm::Parameter and initialize {
			pcmParameter.operationSignature__Parameter = operationSignature
			pcmParameter.dataType__Parameter = TypeReferenceCorrespondenceHelper.
				getDataTypeFromTypeReference(javaParameter.typeReference, correspondenceModel,
				userInteractor, operationSignature.interface__OperationSignature.repository__Interface)
			pcmParameter.name = javaParameter.name
		}
		add correspondence between javaParameter and pcmParameter
		update operationSignature {
			operationSignature.parameters__OperationSignature += pcmParameter
		}
		call {
			checkInnerDeclarationsCreation(pcmParameter.dataType__Parameter, javaParameter.typeReference)
		}
	}
}

routine checkInnerDeclarationsCreation(pcm::DataType type, java::TypeReference typeRef) {
	action {
		call {
			if (type instanceof CompositeDataType) {
				for (mem : (typeRef.target as ConcreteClassifier).members) {
					if (mem instanceof Field) {
						createInnerDeclaration(type, mem)
					}
				}
			}
		}
	}
}

//TODO changed Parameter doesn't work yet
reaction ParameterDeleted {
	after element java::OrdinaryParameter removed from java::Parametrizable[parameters]
	call {
		//oldValue has no correspondence element, but it should
		//this seems to be a bug. If fixed it should have a correspondence and work.
		deleteParameter(oldValue)
	}
}

routine deleteParameter(java::OrdinaryParameter javaParameter) {
	match {
		val pcmParameter = retrieve pcm::Parameter corresponding to javaParameter
	}
	action{
		delete pcmParameter
	}
}

/**
 * Need a special reaction, because Parameter is not a NamedElement.
 */
reaction ParameterNameChanged {
	after attribute replaced at java::Parameter[name]
	call changeParameterName(newValue, affectedEObject)
}

routine changeParameterName(String newName, java::Parameter javaParameter) {
	match {
		val pcmParameter = retrieve pcm::Parameter corresponding to javaParameter
	}
	action {
		update pcmParameter {
			pcmParameter.name = newName
		}
	}
}

/**
 * Check if Field has correspondence to CompositeDataType, ComposedProvidingRequiringEntity, 
 * OperationInterface or RepositoryComponent and react accordingly.
 */
reaction FieldCreated {
	after element java::Field inserted in java::Class[members]
	call {
		val type = getNormalizedClassifierFromTypeReference(newValue.typeReference)
		fieldCreatedCorrespondingToOperationInterface(type, newValue)
	}
}

routine createInnerDeclaration(pcm::CompositeDataType dataType, java::Field javaField) {
	match {
		require absence of pcm::InnerDeclaration corresponding to javaField
		val repository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		val innerDeclaration = create pcm::InnerDeclaration and initialize {
			innerDeclaration.entityName = javaField.name
			innerDeclaration.datatype_InnerDeclaration = TypeReferenceCorrespondenceHelper.
				getDataTypeFromTypeReference(javaField.typeReference, correspondenceModel,
					userInteractor, repository)
			innerDeclaration.compositeDataType_InnerDeclaration = dataType
		}
		add correspondence between innerDeclaration and javaField
		call {
			checkInnerDeclarationsCreation(innerDeclaration.datatype_InnerDeclaration, javaField.typeReference)
		}
	}
}

routine fieldCreatedCorrespondingToOperationInterface(java::Classifier classifier, java::Field javaField) {
	match {
		val correspondingInterface = retrieve pcm::OperationInterface corresponding to classifier
		val correspondingComponent = retrieve pcm::RepositoryComponent corresponding to classifier
		val repositoryComponent = retrieve pcm::RepositoryComponent corresponding to javaField.containingConcreteClassifier
	}
	action {
		call {
			if (correspondingComponent != repositoryComponent) {
				createOperationRequiredRoleCorrespondingToField(javaField, correspondingInterface, repositoryComponent)
			}
		}
	}
}

routine createOperationRequiredRoleCorrespondingToField(java::Field javaField, pcm::OperationInterface operationInterface, pcm::RepositoryComponent repoComponent) {
	action {
		val operationRequiredRole = create pcm::OperationRequiredRole and initialize {
			operationRequiredRole.requiredInterface__OperationRequiredRole = operationInterface
			operationRequiredRole.requiringEntity_RequiredRole = repoComponent
			operationRequiredRole.entityName = "Component_" + repoComponent.entityName + "_requires_" +
				operationInterface.entityName
		}
		add correspondence between operationRequiredRole and javaField
	}
}

routine changeInnerDeclarationType(java::TypeReference typeReference, java::Field javaField) {
	match {
		val innerDeclaration = retrieve pcm::InnerDeclaration corresponding to javaField
		val repository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		update innerDeclaration {
			innerDeclaration.datatype_InnerDeclaration = TypeReferenceCorrespondenceHelper.
				getDataTypeFromTypeReference(typeReference, correspondenceModel, userInteractor, repository)
		}
		call {
			checkInnerDeclarationsCreation(innerDeclaration.datatype_InnerDeclaration, typeReference)
		}
	}
}

reaction ChangeFieldTypeEvent {
	after element replaced at java::Field[typeReference]
	call {
		changeInnerDeclarationType(newValue, affectedEObject)
		if (oldValue !== null) {
			changedFieldTypeEvent(affectedEObject, oldValue, newValue)
		}
	}
}

routine changedFieldTypeEvent(java::Field field, java::TypeReference oldType, java::TypeReference newType) {
	match {
		val oldCorrespondingOpInterface = retrieve optional pcm::OperationInterface corresponding to getNormalizedClassifierFromTypeReference(oldType)
		val oldCorrespondingCom = retrieve optional pcm::RepositoryComponent corresponding to getNormalizedClassifierFromTypeReference(oldType)
		val opInterface = retrieve optional pcm::OperationInterface corresponding to getNormalizedClassifierFromTypeReference(newType)
		val newCom = retrieve optional pcm::RepositoryComponent corresponding to getNormalizedClassifierFromTypeReference(newType)
		val opRequiredRole = retrieve optional pcm::OperationRequiredRole corresponding to field
		val basicComponent = retrieve pcm::BasicComponent corresponding to field.containingConcreteClassifier
	}
	action {
		call {
			if (opRequiredRole.present
					&& oldCorrespondingOpInterface.present && opInterface.present
					&& oldCorrespondingCom.present && newCom.present
					&& newCom.get !== basicComponent) {
				// Reset required role. 
				opRequiredRole.get.requiredInterface__OperationRequiredRole = opInterface.get
				return
			}
			if (!oldCorrespondingOpInterface.present && opInterface.present
					&& newCom.present && newCom.get !== basicComponent) {
				// New required role needs to be added.
				createOperationRequiredRoleCorrespondingToField(field, opInterface.get, basicComponent)
				return
			}
			if (opRequiredRole.present
					&& (oldCorrespondingOpInterface.present && !opInterface.present
					|| oldCorrespondingOpInterface.present && opInterface.present
					&& oldCorrespondingCom.present && newCom.present
					&& newCom.get === basicComponent)) {
				// Remove required role and correspondence.
				removeRequiredRoleAndCorrespondence(opRequiredRole.get, field)
			}
		}
	}
}

routine removeRequiredRoleAndCorrespondence(pcm::OperationRequiredRole orr, java::Field field) {
	action {
		delete orr
	}
}

reaction RemoveFieldEvent {
	after element java::Field removed from java::Class[members]
	call removedFieldEvent(oldValue)
}

routine removedFieldEvent(java::Field field) {
	match {
		val namedElement = retrieve pcm::NamedElement corresponding to field
	}
	action {
		delete namedElement
	}
}

reaction JavaReturnTypeChanged {
	after element java::TypeReference replaced at java::Method[typeReference]
	call changeReturnType(affectedEObject, newValue)
}

routine changeReturnType(java::Method javaMethod, java::TypeReference typeReference) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to javaMethod
	}
	 action {
		 update operationSignature {
			val repository = operationSignature.interface__OperationSignature.repository__Interface
			operationSignature.returnType__OperationSignature = getCorrespondingPCMDataTypeForTypeReference(typeReference, correspondenceModel, userInteractor, repository, javaMethod.typeReference.arrayDimension)
		 }
	 }
}
