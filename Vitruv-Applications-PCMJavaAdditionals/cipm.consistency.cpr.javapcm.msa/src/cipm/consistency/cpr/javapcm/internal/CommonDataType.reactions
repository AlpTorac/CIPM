import org.palladiosimulator.pcm.repository.RepositoryPackage
import org.palladiosimulator.pcm.repository.CompositeDataType
import org.palladiosimulator.pcm.core.entity.Entity
import static extension edu.kit.ipd.sdq.commons.util.java.lang.IterableUtil.claimNotMany
import org.emftext.language.java.classifiers.ConcreteClassifier
import tools.vitruv.applications.pcmjava.util.java2pcm.TypeReferenceCorrespondenceHelper
import org.emftext.language.java.members.Field

import "http://www.emftext.org/java" as java
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm


reactions: commonDataType
in reaction to changes in AdjustedJava
execute actions in PCM


routine checkInnerDeclarationsCreation(pcm::DataType type, java::TypeReference typeRef) {
	action {
		call {
			val refTarget = typeRef.target
			if (type instanceof CompositeDataType && refTarget instanceof ConcreteClassifier) {
				for (mem : (refTarget as ConcreteClassifier).members) {
					if (mem instanceof Field) {
						createInnerDeclaration(type as CompositeDataType, mem)
					}
				}
			}
		}
	}
}

routine createInnerDeclaration(pcm::CompositeDataType dataType, java::Field javaField) {
	match {
		require absence of pcm::InnerDeclaration corresponding to javaField
		val repository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		val innerDeclaration = create pcm::InnerDeclaration and initialize {
			innerDeclaration.entityName = javaField.name
			innerDeclaration.datatype_InnerDeclaration = TypeReferenceCorrespondenceHelper.
				getDataTypeFromTypeReference(javaField.typeReference, correspondenceModel,
					userInteractor, repository)
			innerDeclaration.compositeDataType_InnerDeclaration = dataType
		}
		add correspondence between innerDeclaration and javaField
		call {
			checkInnerDeclarationsCreation(innerDeclaration.datatype_InnerDeclaration, javaField.typeReference)
		}
	}
}

routine changeInnerDeclarationType(java::TypeReference typeReference, java::Field javaField) {
	match {
		val innerDeclaration = retrieve pcm::InnerDeclaration corresponding to javaField
		val repository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		update innerDeclaration {
			innerDeclaration.datatype_InnerDeclaration = TypeReferenceCorrespondenceHelper.
				getDataTypeFromTypeReference(typeReference, correspondenceModel, userInteractor, repository)
		}
		call {
			checkInnerDeclarationsCreation(innerDeclaration.datatype_InnerDeclaration, typeReference)
		}
	}
}

routine renameDataType(java::ConcreteClassifier classifier) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		call {
			val foundDataType = pcmRepository.dataTypes__Repository.filter(Entity)
				.filter[it.entityName === classifier.name].claimNotMany
			if (foundDataType !== null) {
				internalRenameDataType(classifier, foundDataType)
			}
		}
	}
}

routine internalRenameDataType(java::ConcreteClassifier classifier, pcm::Entity dataType) {
	action {
		update dataType {
			dataType.entityName = classifier.name
		}
	}
}

routine checkDataTypeRemoval(java::ConcreteClassifier javaClass) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		call {
			val foundDataType = pcmRepository.dataTypes__Repository.filter(Entity)
				.filter[it.entityName == javaClass.name].claimNotMany
			if (foundDataType !== null) {
				removeDataType(foundDataType)
			}
		}
	}
}

routine removeDataType(pcm::Entity type) {
	action {
		delete type
	}
}
