import org.emftext.language.java.classifiers.Class
import org.emftext.language.java.types.ClassifierReference
import org.emftext.language.java.types.NamespaceClassifierReference

import org.palladiosimulator.pcm.repository.RepositoryPackage
import org.palladiosimulator.pcm.repository.CompositeDataType
import org.palladiosimulator.pcm.repository.CollectionDataType
import org.palladiosimulator.pcm.core.entity.Entity

import tools.vitruv.applications.pcmjava.pojotransformations.java2pcm.Java2PcmUserSelection
import tools.vitruv.framework.userinteraction.UserInteractionOptions.WindowModality

import static extension tools.vitruv.applications.util.temporary.java.JavaMemberAndParameterUtil.hasSameSignature
import static extension edu.kit.ipd.sdq.commons.util.java.lang.IterableUtil.claimNotMany
import static tools.vitruv.applications.util.temporary.java.JavaTypeUtil.*
import org.palladiosimulator.pcm.repository.OperationRequiredRole
import tools.vitruv.applications.pcmjava.integrationFromGit.response.internal.InternalUtility
import org.emftext.language.java.containers.Origin

import "http://www.emftext.org/java" as java
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm


reactions: packageAndClassifiers
in reaction to changes in AdjustedJava
execute actions in PCM


reaction AddImportReaction {
	after element java::Import inserted in java::JavaRoot[imports]
	call {
		checkImportForImportedRequiredRoles(newValue)
	}
}

routine checkImportForImportedRequiredRoles(java::Import importSt) {
	action {
		call {
			for (classifier : importSt.containingCompilationUnit.classifiers) {
				createOrFindRequiredRole(importSt, classifier)
			}
		}
	}
}

routine checkClassifierForImportedRequiredRoles(java::ConcreteClassifier classifier) {
	action {
		call {
			for (importSt : classifier.containingCompilationUnit.imports) {
				createOrFindRequiredRole(importSt, classifier)
			}
		}
	}
}

routine createOrFindRequiredRole(java::Import importSt, java::ConcreteClassifier importingClassifier) {
	match {
		val opInterface = retrieve pcm::OperationInterface corresponding to importSt.classifier
		val opInterfaceCom = retrieve pcm::RepositoryComponent corresponding to importSt.classifier
		val containingCom = retrieve pcm::RepositoryComponent corresponding to importingClassifier
	}
	action {
		call {
			if (opInterfaceCom !== containingCom) {
				for (reqRole : containingCom.requiredRoles_InterfaceRequiringEntity) {
					if (reqRole instanceof OperationRequiredRole
							&& reqRole.requiringEntity_RequiredRole === containingCom) {
						addCorrespondenceForImportAndRequiredRole(importSt, reqRole as OperationRequiredRole)
						return;
					}
				}
				createRequiredRoleForImport(importSt, opInterface, containingCom)
			}
		}
	}
}

routine createRequiredRoleForImport(java::Import importSt, pcm::OperationInterface opInterface,
		pcm::RepositoryComponent requiringCom) {
	match {
		require absence of pcm::OperationRequiredRole corresponding to importSt
	}
	action {
		val reqRole = create pcm::OperationRequiredRole and initialize {
			reqRole.requiredInterface__OperationRequiredRole = opInterface
			reqRole.requiringEntity_RequiredRole = requiringCom
			reqRole.entityName = "Component_" + requiringCom.entityName + "_requires_"
				+ opInterface.entityName
		}
		call {
			addCorrespondenceForImportAndRequiredRole(importSt, reqRole)
		}
	}
}

routine addCorrespondenceForImportAndRequiredRole(java::Import importSt, pcm::OperationRequiredRole reqRole) {
	action {
		add correspondence between importSt and reqRole
	}
}

reaction RemoveImportReaction {
	after element java::Import removed from java::JavaRoot[imports]
	call {
		removeRequiredRoleForImport(oldValue)
	}
}

routine removeRequiredRoleForImport(java::Import importSt) {
	match {
		val reqRole = retrieve pcm::OperationRequiredRole corresponding to importSt
		val allImports = retrieve many java::Import corresponding to reqRole
	}
	action {
		call {
			if (allImports.size === 1) {
				removeRequiredRole(reqRole)
			} else {
				removeCorrespondenceForImportAndRequiredRole(importSt, reqRole)
			}
		}
	}
}

routine removeRequiredRole(pcm::OperationRequiredRole reqRole) {
	action {
		delete reqRole
	}
}

routine removeCorrespondenceForImportAndRequiredRole(java::Import importSt, pcm::OperationRequiredRole reqRole) {
	action {
		remove correspondence between importSt and reqRole
	}
}



//empty implementation for add and remove class annotation
reaction AddClassAnnotationReaction {
	after element inserted in java::Class[annotationsAndModifiers]
	call {}
}

reaction RemoveClassAnnotationReaction {
	after element removed from java::Class[annotationsAndModifiers]
	call {}
}

//Create Interface Method:
reaction InterfaceMethodCreated {
	after element java::InterfaceMethod inserted in java::Interface[members] 
	call {
		createOrFindPCMSignature(newValue)
	}
}

routine createOrFindPCMSignature(java::Method interfaceMethod) {
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to interfaceMethod.containingConcreteClassifier
		require absence of pcm::OperationSignature corresponding to interfaceMethod
	}
	action {
		call {
			for (sign : pcmInterface.signatures__OperationInterface) {
				if (sign.entityName.equals(interfaceMethod.name)) {
					addCorrespondenceBetweenMethodAndOperationSignature(interfaceMethod, sign)
					return;
				}
			}
			createPCMSignature(interfaceMethod)
		}
	}
}

routine createPCMSignature(java::Method interfaceMethod) {
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to interfaceMethod.containingConcreteClassifier
		require absence of pcm::OperationSignature corresponding to interfaceMethod
	}
	action {
		val operationSignature = create pcm::OperationSignature and initialize {
			operationSignature.entityName = interfaceMethod.name
			operationSignature.interface__OperationSignature = pcmInterface
		}
		
		update pcmInterface {
			pcmInterface.signatures__OperationInterface += operationSignature
		}
		
		call {
			addCorrespondenceBetweenMethodAndOperationSignature(interfaceMethod, operationSignature)
		}
	}
}

routine addCorrespondenceBetweenMethodAndOperationSignature(java::Method method, pcm::OperationSignature sign) {
	action {
		add correspondence between sign and method
	}
}

//Create Class Method:
reaction ClassMethodCreated {
	after element java::ClassMethod inserted in java::Class[members]
	call {
		if (newValue.public) {
			createOrFindPCMSignature(newValue)
		}
		createSeffFromImplementingInterfaces(newValue, affectedEObject)
		createSeffFromClassInterface(newValue, affectedEObject)
	}
}

routine createSeffFromClassInterface(java::ClassMethod method, java::Class javaClass) {
	match {
		val opInterface = retrieve pcm::OperationInterface corresponding to javaClass
		require absence of pcm::ResourceDemandingSEFF corresponding to method
	}
	action {
		call {
			if (method.public && !method.static) {
				createSEFF(method, javaClass, method)
			}
		}
	}
}

routine createSeffFromImplementingInterfaces(java::ClassMethod classMethod, java::Class javaClass) {
	match {
		require absence of pcm::ResourceDemandingSEFF corresponding to classMethod
	}
	action {
		call {
			val implementingInterfaces = findImplementingInterfacesFromTypeRefs(javaClass.implements)
			for (implementingInterface : implementingInterfaces) {
				createSeffFromImplementingInterface(classMethod, javaClass, implementingInterface)
			}
		}
	}
}

routine createSeffFromImplementingInterface(java::ClassMethod classMethod, java::Class javaClass, java::Interface javaInterface) {
	match {
		val operationInterface = retrieve pcm::OperationInterface corresponding to javaInterface
	} 
	action {
		call {
			val methods = javaInterface.methods.filter[hasSameSignature(classMethod)]
			for (method : methods) {
				createSEFF(method, javaClass, classMethod)
			}
		}
	}
}

routine createSEFF(java::Method javaMethod, java::Class javaClass, java::ClassMethod classMethod) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to javaMethod
		val basicComponent = retrieve pcm::BasicComponent corresponding to javaClass
	}
	action {
		val rdseff = create pcm::ResourceDemandingSEFF and initialize {
			rdseff.describedService__SEFF = operationSignature
			rdseff.basicComponent_ServiceEffectSpecification = basicComponent
		}
		add correspondence between classMethod and rdseff
		
		update basicComponent {
			basicComponent.serviceEffectSpecifications__BasicComponent += rdseff
		}
	}
}

//Remove Interface Method
reaction RemoveInterfaceMethodEvent {
	after element java::InterfaceMethod removed from java::Interface[members] 
	call removedInterfaceMethodEvent(oldValue)
} 

routine removedInterfaceMethodEvent(java::Method interfaceMethod) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to interfaceMethod
		val classifiers = retrieve many java::ConcreteClassifier corresponding to operationSignature
	}
	action {
		call {
			if (classifiers.size == 1) {
				deleteSignature(operationSignature);
			} else {
				removeCorrespondenceBetweenMethodAndSignature(interfaceMethod, operationSignature)
			}
		}
	}
}

routine deleteSignature(pcm::OperationSignature sign) {
	action {
		// Should the correspoding SEFFs still exist?
		// Should the references to the removed OperationSignature in all rdseff.describedService__SEFF also be removed?
		delete sign
	}
}

routine removeCorrespondenceBetweenMethodAndSignature(java::Method method, pcm::OperationSignature sign) {
	action {
		remove correspondence between method and sign
	}
}

//Remove Class Method
reaction RemoveClassMethodEvent {
	after element java::ClassMethod removed from java::Class[members]
	call {
		removedClassMethodEvent(oldValue)
		removedInterfaceMethodEvent(oldValue)
	}
} 

routine removedClassMethodEvent(java::ClassMethod classMethod) {
	match {
		//val operationSignature = retrieve pcm::OperationSignature corresponding to classMethod
		val seff = retrieve pcm::ResourceDemandingSEFF corresponding to classMethod
	}
	action {
		delete seff
	}
}

//Create Class
reaction ClassCreated {
	after element java::Class inserted in java::CompilationUnit[classifiers]
	call {
//		decideDataTypeCreation(newValue)
		createOrFindArchitecturalElement(newValue)
		decideInterfaceCreation(newValue)
		createOrFindOperationProvidedRole(newValue, newValue)
		checkClassifierForImportedRequiredRoles(newValue)
	}
}

routine createOrFindArchitecturalElement(java::ConcreteClassifier classifier) {
	match {
		require absence of pcm::RepositoryComponent corresponding to classifier
	}
	action {
		call {
			val module = InternalUtility.getModule(classifier)
			if (module === null) {
				return
			}
			createOrFindArchitecturalElementBasedOnModule(classifier, module)
		}
	}
}

routine createOrFindArchitecturalElementBasedOnModule(java::ConcreteClassifier classifier, java::Module module) {
	match {
		val pcmComponent = retrieve optional pcm::RepositoryComponent corresponding to module
	}
	action {
		call {
			if (!pcmComponent.isPresent) {
				createBasicComponent(module)
			}
			addCorrespondenceForPcmComponentAndClassifierBasedOnModule(classifier, module)
		}
	}
}

//Create Interface
reaction InterfaceCreated {
	after element java::Interface inserted in java::CompilationUnit[classifiers]
	call {
		createOrFindArchitecturalElement(newValue)
		decideInterfaceCreation(newValue)
		checkClassifierForImportedRequiredRoles(newValue)
	}
}

routine decideInterfaceCreation(java::ConcreteClassifier javaInterface) {
	match {
		val com = retrieve pcm::RepositoryComponent corresponding to javaInterface
	}
	action {
		call {
			var mod = InternalUtility.getModule(javaInterface)
			if (mod === null) {
				return
			}
			if (mod.origin == Origin.FILE) {
				for (annot : javaInterface.annotationInstances) {
					val annotName = annot.annotation.name
					if (annotName.equals("Path") || annotName.equals("ApplicationPath")) {
						createOrFindInterface(javaInterface)
						return
					}
				}
				for (cc : javaInterface.allSuperClassifiers) {
					if (cc.name.equals("HttpServlet")) {
						createOrFindInterface(javaInterface)
						return
					}
				}
			} else if (mod.origin == Origin.ARCHIVE) {
				if (javaInterface.public) {
					createOrFindInterface(javaInterface)
				}
			}
		}
	}
}

routine createOrFindInterface(java::ConcreteClassifier classifier) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
		require absence of pcm::OperationInterface corresponding to classifier
	}
	action {
		call {
			for (inter : pcmRepository.interfaces__Repository) {
				if (inter.entityName.equals(classifier.name)) {
					val userMessage = "There is already an PCM interface with the name " + inter.entityName
						+ ". Is the classifier " + classifier.qualifiedName
						+ " a duplication of the classifier corresponding to the existing PCM interface?"
					var selection = userInteractor.confirmationDialogBuilder.message(userMessage).startInteraction
					if (selection) {
						addCorrespondenceBetweenClassifierAndInterface(classifier, inter)
						return	
					}
				}
			}
			createInterface(classifier)
		}
	}
}

routine createInterface(java::ConcreteClassifier javaInterface) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
		require absence of pcm::OperationInterface corresponding to javaInterface
	}
	action {
		val pcmInterface = create pcm::OperationInterface and initialize {
			pcmInterface.entityName = javaInterface.name
		}
		update pcmRepository {
			pcmRepository.interfaces__Repository += pcmInterface
		}
		call {
			addCorrespondenceBetweenClassifierAndInterface(javaInterface, pcmInterface)
		}
	}
}

routine addCorrespondenceBetweenClassifierAndInterface(java::ConcreteClassifier javaClassifier, pcm::Interface pcmInterface) {
	action {
		add correspondence between javaClassifier and pcmInterface
	}
}

//Remove Class
reaction RemoveClassEvent {
	after element java::Class removed from java::CompilationUnit[classifiers]
	call {
		removedClassEvent(oldValue)
	}
} 

routine removedClassEvent(java::ConcreteClassifier clazz) {
	match {
		val pcmComponent = retrieve pcm::RepositoryComponent corresponding to clazz
		val otherClassifiers = retrieve many java::ConcreteClassifier corresponding to pcmComponent
	}
	action {
		remove correspondence between clazz and pcmComponent
		call {
			if (otherClassifiers.size == 1) {
				removeComponent(pcmComponent)
			}
		}
	}
}

routine removeComponent(pcm::RepositoryComponent com) {
	action {
		delete com
	}
}

//Remove Interface
reaction RemoveInterfaceEvent {
	after element java::Interface removed from java::CompilationUnit[classifiers]
	call {
		removedClassEvent(oldValue)
	}
} 

//Add implements
reaction TypeReferenceCreated {
	after element java::TypeReference inserted in java::Class[implements]
		with newValue instanceof NamespaceClassifierReference || newValue instanceof ClassifierReference
	call {
		createOrFindOperationProvidedRoleFromTypeReference(newValue)
	}
}

routine createOrFindOperationProvidedRoleFromTypeReference(java::TypeReference typeReference) {
	action {
		call {
			val javaClass = typeReference.eContainer as Class
			var javaInterfaceClassifier = getNormalizedClassifierFromTypeReference(typeReference)
			createOrFindOperationProvidedRole(javaInterfaceClassifier, javaClass)
		}
	}
}

routine createOrFindOperationProvidedRole(java::Classifier classifierInterface, java::Class javaClass) {
	match {
		val opInterface = retrieve pcm::OperationInterface corresponding to classifierInterface
		val basicComponent = retrieve pcm::BasicComponent corresponding to javaClass
		val provRoles = retrieve many pcm::OperationProvidedRole corresponding to javaClass
	}
	action {
		call {
			val role = provRoles.findFirst[it.providedInterface__OperationProvidedRole === opInterface
				&& it.providingEntity_ProvidedRole === basicComponent]
			if (role === null) {
				createOperationProvidedRole(opInterface, basicComponent, javaClass)
			}
		}
	}
}

routine createOperationProvidedRole(pcm::OperationInterface opInterface, pcm::BasicComponent basicComponent, java::Class javaClass) {
	action {
		val operationProvidedRole = create pcm::OperationProvidedRole and initialize {
			operationProvidedRole.providedInterface__OperationProvidedRole = opInterface
			operationProvidedRole.providingEntity_ProvidedRole = basicComponent
			operationProvidedRole.entityName = basicComponent.entityName + "_provides_" + opInterface.entityName
		}
		add correspondence between operationProvidedRole and javaClass 
	}
}

//Remove implements
reaction TypeReferenceRemoved {
	after element java::TypeReference removed from java::Class[implements]
		with oldValue instanceof NamespaceClassifierReference || oldValue instanceof ClassifierReference
	call {
//		removeOperationProvidedRole(oldValue)	
	}
}

routine removeOperationProvidedRole(java::TypeReference typeReference) {
	match {
		val operationProvidedRole = retrieve pcm::OperationProvidedRole corresponding to typeReference
	}
	action {
		delete operationProvidedRole
	}
}

routine createBasicComponent(java::Module module) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		val pcmBasicComponent = create pcm::BasicComponent and initialize {
			pcmBasicComponent.entityName = module.name
		}
		update pcmRepository {
			pcmRepository.components__Repository += pcmBasicComponent
		}
		add correspondence between pcmBasicComponent and module
	}
}

routine createCompositeComponent(java::Package javaPackage, String name, String rootPackageName) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		val pcmCompositeComponent = create pcm::CompositeComponent and initialize {
			pcmCompositeComponent.entityName = name
		}		
		call {
//			addCorrespondenceAndUpdateRepository(pcmCompositeComponent, javaPackage, pcmRepository)
		}
	}
}

routine addCorrespondenceForPcmComponentAndClassifierBasedOnModule(java::ConcreteClassifier classifier, java::Module module) {
	match {
		val pcmComponent = retrieve pcm::RepositoryComponent corresponding to module
	}
	action {
		add correspondence between pcmComponent and classifier
	}
}

routine renameComponent(java::Package javaPackage) {
	match {
		val pcmComponent = retrieve pcm::RepositoryComponent corresponding to javaPackage
	}
	action {
		update pcmComponent {
			pcmComponent.entityName = javaPackage.name.toFirstUpper;
		}
	}
}

reaction JavaInterfaceRenamed {
	after attribute replaced at java::Interface[name]
	call {
		renameInterface(affectedEObject)
	}
}

routine renameInterface(java::ConcreteClassifier javaInterface) {
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to javaInterface
	}
	action {
		update pcmInterface {
			pcmInterface.entityName = javaInterface.name
		}
	}
}

//Class
reaction JavaClassRenamed {
	after attribute replaced at java::Class[name]
	call {
//		renameComponentFromClass(affectedEObject)
		renameDataTypeFromClass(affectedEObject)
		renameInterface(affectedEObject)
	}
}

routine renameComponentFromClass(java::Class javaClass) {
	match {
		val pcmComponent = retrieve pcm::RepositoryComponent corresponding to javaClass
	}
	action {
		update pcmComponent {
			var newName = javaClass.name.toFirstUpper
			if (newName.endsWith("Impl")) newName = newName.substring(0, newName.length - "Impl".length)
			pcmComponent.entityName = newName
		}
	}
}

routine renameDataTypeFromClass(java::Class javaClass) {
	match {
		val dataType = retrieve pcm::DataType corresponding to javaClass
	}
	action {
		update dataType {
			if(dataType instanceof Entity) { // primitive data types don't have names
				dataType.entityName = javaClass.name.toFirstUpper
			}
		}
	}
}

/**
 * User can choose if a composite or collection data type should be created.
 */
routine decideDataTypeCreation(java::Class javaClass) {
	match {
		require absence of pcm::DataType corresponding to javaClass
	}
	action {
		call {
			val String userMsg = "Class " + javaClass.name +
						" has been created. Please decide which kind of data type should be created."
			val String[] selections = #[Java2PcmUserSelection.SELECT_COMPOSITE_DATA_TYPE.message,
				Java2PcmUserSelection.SELECT_COLLECTION_DATA_TYPE.message,
				Java2PcmUserSelection.SELECT_NOTHING_DECIDE_LATER.message
			]
			val selected = userInteractor.singleSelectionDialogBuilder.message(userMsg).choices(selections)
				.windowModality(WindowModality.MODAL).startInteraction()
			switch(selected) {
				case Java2PcmUserSelection.SELECT_COMPOSITE_DATA_TYPE.selection: 
					createOrFindCompositeDataType(javaClass)
				case Java2PcmUserSelection.SELECT_COLLECTION_DATA_TYPE.selection: 
					createOrFindCollectionDataType(javaClass)
			}
		}
	}
}

routine createOrFindCompositeDataType(java::Class javaClass) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		call {
			val foundCompositeDataType = pcmRepository.dataTypes__Repository.filter(CompositeDataType)
				.filter[entityName.toFirstUpper == javaClass.name.toFirstUpper || javaClass.name === null && entityName == "aName"].claimNotMany
			if (foundCompositeDataType === null) {
				createCompositeDataType(javaClass)
			} else {
				addDataTypeCorrespondence(javaClass, foundCompositeDataType)
			}
		}
	}
}

routine createCompositeDataType(java::Class javaClass) {
	action {
		val pcmCompositeDataType = create pcm::CompositeDataType and initialize {
			pcmCompositeDataType.entityName = javaClass.name
		}
		add correspondence between pcmCompositeDataType and javaClass
		call {
			addDataTypeCorrespondence(javaClass, pcmCompositeDataType)
			addDataTypeInRepository(pcmCompositeDataType)
		}
	}
}

routine createOrFindCollectionDataType(java::Class javaClass) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		call {
			val foundCollectionDataType = pcmRepository.dataTypes__Repository.filter(CollectionDataType)
				.filter[entityName.toFirstUpper == javaClass.name.toFirstUpper || javaClass.name === null && entityName == "aName"].claimNotMany
			if (foundCollectionDataType === null) {
				createCollectionDataType(javaClass)
			} else {
				addDataTypeCorrespondence(javaClass, foundCollectionDataType)
			}
		}
	}
}

routine createCollectionDataType(java::Class javaClass) {
	action {
		val pcmCollectionDataType = create pcm::CollectionDataType and initialize {
			pcmCollectionDataType.entityName = javaClass.name
		}
		call {
			addDataTypeCorrespondence(javaClass, pcmCollectionDataType)
			addDataTypeInRepository(pcmCollectionDataType)
		}
	}
}

routine addDataTypeCorrespondence(java::Class javaClass, pcm::DataType dataType) {
	action {
		add correspondence between dataType and javaClass
	}
}

routine addDataTypeInRepository(pcm::DataType pcmDataType) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		update pcmDataType {
			pcmDataType.repository__DataType = pcmRepository
		}
		update pcmRepository {
			pcmRepository.dataTypes__Repository += pcmDataType
		}
	}
}
