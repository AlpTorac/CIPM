package org.splevo.diffing.emfcompare.tests;

import java.io.File;
import java.io.IOException;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.compare.diff.engine.IDiffEngine;
import org.eclipse.emf.compare.diff.metamodel.AbstractDiffExtension;
import org.eclipse.emf.compare.diff.metamodel.ComparisonResourceSetSnapshot;
import org.eclipse.emf.compare.diff.metamodel.ComparisonResourceSnapshot;
import org.eclipse.emf.compare.diff.metamodel.DiffElement;
import org.eclipse.emf.compare.diff.metamodel.DiffFactory;
import org.eclipse.emf.compare.diff.metamodel.DiffModel;
import org.eclipse.emf.compare.diff.metamodel.DiffResourceSet;
import org.eclipse.emf.compare.diff.metamodel.ModelElementChange;
import org.eclipse.emf.compare.diff.metamodel.ModelElementChangeLeftTarget;
import org.eclipse.emf.compare.diff.metamodel.ModelElementChangeRightTarget;
import org.eclipse.emf.compare.diff.metamodel.ReferenceChange;
import org.eclipse.emf.compare.diff.metamodel.ReferenceChangeLeftTarget;
import org.eclipse.emf.compare.diff.metamodel.ReferenceChangeRightTarget;
import org.eclipse.emf.compare.diff.metamodel.ResourceDependencyChange;
import org.eclipse.emf.compare.diff.metamodel.UpdateReference;
import org.eclipse.emf.compare.diff.service.DiffService;
import org.eclipse.emf.compare.match.MatchOptions;
import org.eclipse.emf.compare.match.engine.DefaultMatchScopeProvider;
import org.eclipse.emf.compare.match.engine.IMatchEngine;
import org.eclipse.emf.compare.match.metamodel.MatchModel;
import org.eclipse.emf.compare.match.metamodel.MatchPackage;
import org.eclipse.emf.compare.match.metamodel.MatchResourceSet;
import org.eclipse.emf.compare.match.metamodel.Side;
import org.eclipse.emf.compare.match.metamodel.UnmatchModel;
import org.eclipse.emf.compare.match.service.MatchService;
import org.eclipse.emf.compare.util.EMFCompareMap;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature.Setting;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.util.EcoreUtil.CrossReferencer;
import org.eclipse.emf.ecore.xmi.XMLResource;
import org.junit.Before;
import org.junit.Test;
import org.splevo.diffing.emfcompare.diff.KdmDiffEngine;
import org.splevo.diffing.emfcompare.diff.transform.DiffTreeTransformer;
import org.splevo.diffing.emfcompare.match.JavaModelMatchEngine;

/**
 * Test case for diffing KDM models generated by Modisco.
 * 
 * Currently, it expects the CaseStudyCalculatorProject to be checked out as a
 * workspace project
 * 
 * @author Henrich Kolkhorst
 * 
 */
public class KDMDiffTest {
	private static final File NATIVE_MODEL_FILE = new File(
			"../CaseStudyCalculatorProject/models/implementation/native/_java.xmi");
	private static final File JSCIENCE_MODEL_FILE = new File(
			"../CaseStudyCalculatorProject/models/implementation/jscience/_java.xmi");
	private EObject jscienceModel;
	private EObject nativeModel;
	private Resource rightResource;
	private Resource leftResource;
	private final IMatchEngine matchEngine = new JavaModelMatchEngine();
	private final IDiffEngine diffEngine = new KdmDiffEngine();
	

	/**
	 * Load both Calculator models
	 * 
	 * @throws Exception
	 *             possible load exception
	 */
	@Before
	public void setUp() throws Exception {
		rightResource = loadModelResource(JSCIENCE_MODEL_FILE);
		if (rightResource.getContents().size() > 0) {
			jscienceModel = rightResource.getContents().get(0);
		}
		leftResource = loadModelResource(NATIVE_MODEL_FILE);
		if (leftResource.getContents().size() > 0) {
			nativeModel = leftResource.getContents().get(0);
		}

		matchEngine.reset();
		diffEngine.reset();
	}

	/**
	 * Generate an *.emfdiff file in the current project folder
	 * 
	 * @throws Exception
	 *             possible diffing exception
	 */
	@Test
	public void testDiff() throws Exception {
		DefaultMatchScopeProvider matchScopeProvider = new DefaultMatchScopeProvider(
				leftResource.getResourceSet(), rightResource.getResourceSet());
		final Map<String, Object> options = new EMFCompareMap<String, Object>();

		// do comparison
		final MatchResourceSet matchResourceSet;
			options.put(MatchOptions.OPTION_MATCH_SCOPE_PROVIDER, new DefaultMatchScopeProvider(
					leftResource.getResourceSet(), rightResource.getResourceSet()));
			matchResourceSet = MatchService.doResourceSetMatch(leftResource.getResourceSet(),
					rightResource.getResourceSet(), options);
		Map<String, Object> matchOptions = new EMFCompareMap<String, Object>();
		matchOptions.put(MatchOptions.OPTION_MATCH_SCOPE_PROVIDER,
				matchScopeProvider);
		
		
		DiffResourceSet diffSet = DiffFactory.eINSTANCE.createDiffResourceSet();
		final CrossReferencer crossReferencer = new CrossReferencer(diffSet) {
			private static final long serialVersionUID = 2615156054928729681L;

			{
				crossReference();
			}
			
			@Override
			protected boolean crossReference(EObject eObject, EReference eReference, EObject crossReferencedEObject) {
				// FIXME shouldn't we test for eObject instanceof Match2Elements?
				// Cross reference this if it is either one of the left, right, or ancestor elements
				boolean crossReference = eReference == MatchPackage.eINSTANCE.getMatch2Elements_LeftElement()
						|| eReference == MatchPackage.eINSTANCE.getMatch2Elements_RightElement()
						|| eReference == MatchPackage.eINSTANCE.getMatch3Elements_OriginElement();

				// Or if it is an unmatched element
				crossReference = crossReference || eReference == MatchPackage.eINSTANCE.getUnmatchElement_Element();

				if (crossReference) {
					super.crossReference(eObject, eReference, crossReferencedEObject);
				}

				return crossReference;
			}
		};
		
		for (final MatchModel match : matchResourceSet.getMatchModels()) {
			final DiffModel diffmodel = diffEngine.doDiffResourceSet(match, false, crossReferencer);

			final Collection<AbstractDiffExtension> extensions = DiffService
					.getCorrespondingDiffExtensions(match);
			for (final AbstractDiffExtension ext : extensions) {
				if (ext != null) {
					ext.visit(diffmodel);
				}
			}

			diffEngine.reset();
			diffSet.getDiffModels().add(diffmodel);
		}
		for (final UnmatchModel unmatch : matchResourceSet.getUnmatchedModels()) {
			ResourceDependencyChange dependencyChange;
			if (unmatch.getSide() == Side.LEFT) {
				dependencyChange = DiffFactory.eINSTANCE.createResourceDependencyChangeLeftTarget();
			} else {
				dependencyChange = DiffFactory.eINSTANCE.createResourceDependencyChangeRightTarget();
			}
			if (unmatch.isRemote()) {
				dependencyChange.setRemote(true);
			}
			dependencyChange.getRoots().addAll(unmatch.getRoots());
			diffSet.getResourceDiffs().add(dependencyChange);
		}

		fillRequiredDifferences(diffSet);
		//saveDiff(new File("testDiff.emfdiff"), matchModel, diffModel);
		
		final ComparisonResourceSetSnapshot snapshot = DiffFactory.eINSTANCE
				.createComparisonResourceSetSnapshot();
		snapshot.setDate(Calendar.getInstance().getTime());
		snapshot.setMatchResourceSet(matchResourceSet);
		snapshot.setDiffResourceSet(diffSet);

		File targetFile = new File("testDiff.emfdiff");
		Resource newModelRes = (new ResourceSetImpl()).createResource(URI
				.createFileURI(targetFile.getPath()));
		newModelRes.getContents().add(snapshot);
		final Map<String, String> saveOptions = new EMFCompareMap<String, String>();
		saveOptions.put(XMLResource.OPTION_ENCODING,
				"UTF-8");
		newModelRes.save(saveOptions);
		
		DiffTreeTransformer transformer = new DiffTreeTransformer();
		transformer.convertModel(snapshot);
	}
	
	
	
	/**
	 * Post-processing on the DiffModel or DiffResourceSet to fill each {@link ModelElementChange} with
	 * possible required others differences.
	 * 
	 * @param model
	 *            The DiffModel or DiffResourceSet.
	 */
	private static void fillRequiredDifferences(EObject model) {
		EcoreUtil.CrossReferencer crossReferencer = new EcoreUtil.CrossReferencer(model) {
			/** Generic Serial ID. */
			private static final long serialVersionUID = 1L;

			{
				crossReference();
			}
		};

		final Iterator<EObject> diffs = model.eAllContents();
		while (diffs.hasNext()) {
			final EObject obj = diffs.next();
			if ((obj instanceof ModelElementChange || obj instanceof ReferenceChange)
					&& !(obj instanceof AbstractDiffExtension)) {
				fillRequiredDifferences(crossReferencer, (DiffElement)obj);
			}
		}
	}

	/**
	 * Fill the specified difference with a possible required other difference.
	 * 
	 * @param crossReferencer
	 *            Cross referencer on the DiffModel or DiffResourceSet.
	 * @param diff
	 *            The difference to fill.
	 */
	private static void fillRequiredDifferences(EcoreUtil.CrossReferencer crossReferencer,
			final DiffElement diff) {
		final Set<EObject> refEObjects = getReferencedEObjects(diff);
		final Iterator<EObject> referencedEObjects = refEObjects.iterator();
		while (referencedEObjects.hasNext()) {
			final EObject referencedEObject = referencedEObjects.next();
			final Collection<Setting> settings = crossReferencer.get(referencedEObject);
			if (settings != null) {
				for (Setting setting : settings) {
					final EObject crossElt = setting.getEObject();
					linkDifferences(diff, crossElt);
				}
			}
		}

	}

	/**
	 * Get the all the referenced model objects from the specified difference.
	 * 
	 * @param diff
	 *            The difference.
	 * @return The list of the model objects.
	 */
	private static Set<EObject> getReferencedEObjects(final DiffElement diff) {
		EObject elt = null;
		final Set<EObject> referencedEObjects = new LinkedHashSet<EObject>();
		if (diff instanceof ModelElementChangeLeftTarget) {
			final ModelElementChangeLeftTarget mec = (ModelElementChangeLeftTarget)diff;
			elt = mec.getLeftElement();
//			referencedEObjects.addAll(DiffReferenceUtil.getReferencedEObjects(elt, true));
			referencedEObjects.remove(elt);
		} else if (diff instanceof ModelElementChangeRightTarget) {
			final ModelElementChangeRightTarget mec = (ModelElementChangeRightTarget)diff;
			elt = mec.getRightElement();
//			referencedEObjects.addAll(DiffReferenceUtil.getReferencedEObjects(elt, true));
			referencedEObjects.remove(elt);
		} else if (diff instanceof ReferenceChangeLeftTarget) {
			final ReferenceChangeLeftTarget rc = (ReferenceChangeLeftTarget)diff;
			final EObject leftTarget = rc.getLeftTarget();
			if (leftTarget != null) {
				referencedEObjects.add(leftTarget);
			}
		} else if (diff instanceof ReferenceChangeRightTarget) {
			final ReferenceChangeRightTarget rc = (ReferenceChangeRightTarget)diff;
			final EObject rightTarget = rc.getRightTarget();
			if (rightTarget != null) {
				referencedEObjects.add(rightTarget);
			}
		} else if (diff instanceof UpdateReference) {
			final UpdateReference ur = (UpdateReference)diff;
			final EObject leftTarget = ur.getLeftTarget();
			final EObject rightTarget = ur.getRightTarget();
			if (leftTarget != null && leftTarget != ur.getLeftElement()) {
				referencedEObjects.add(leftTarget);
			}
			if (rightTarget != null && rightTarget != ur.getRightElement()) {
				referencedEObjects.add(rightTarget);
			}
		}
		return referencedEObjects;
	}

	/**
	 * Checks if the given difference {@link dest} is a good candidate to be added as required difference the
	 * specified difference {@link origin}. A good candidate is a {@link ModelElementChange} which is not an
	 * {@link AbstractDiffExtension}.
	 * 
	 * @param origin
	 *            The difference to fill.
	 * @param dest
	 *            The difference candidate.
	 */
	private static void linkDifferences(final DiffElement origin, final EObject dest) {
		if (dest instanceof ModelElementChange && !(dest instanceof AbstractDiffExtension)) {
			final ModelElementChange mec = (ModelElementChange)dest;
			//origin.getRequires().add(mec);
			/*
			 * In the case of UpdateReference differences, we've set the left and/or right target to an
			 * unmatched value. We need to null out that value now in order not to merge it and use the result
			 * of the ModelElementChange merging.
			 */
			if (origin instanceof UpdateReference) {
				final UpdateReference updateDiff = (UpdateReference)origin;
				final EObject changedElement;
				if (mec instanceof ModelElementChangeLeftTarget) {
					changedElement = ((ModelElementChangeLeftTarget)mec).getLeftElement();
				} else if (mec instanceof ModelElementChangeRightTarget) {
					changedElement = ((ModelElementChangeRightTarget)mec).getRightElement();
				} else {
					changedElement = null;
				}
				if (updateDiff.getLeftTarget() == changedElement) {
					updateDiff.setLeftTarget(null);
				} else if (updateDiff.getRightTarget() == changedElement) {
					updateDiff.setRightTarget(null);
				}
			}
		}
	}
	
	/**
	 * Loads an Ecore model from the supplied file
	 * 
	 * @param modelFile
	 *            model to load
	 * @return model instance
	 * @throws IOException
	 *             possible load exception
	 */
	private Resource loadModelResource(File modelFile) throws IOException {
		if (!modelFile.canRead()) {
			throw new IllegalArgumentException("cannot read model file "
					+ modelFile.getAbsolutePath());
		}
		ResourceSet resSet = new ResourceSetImpl();
		URI fileUri = URI.createFileURI(modelFile.getPath());
		Resource resource = resSet.createResource(fileUri);
		resource.load(Collections.emptyMap());

		
		return resource;
	}

	/**
	 * Saves an EMF Compare result to a file.
	 * 
	 * @param targetFile
	 *            target serialization file
	 * @param matchModel
	 *            matched model generated by EMF Compare
	 * @param diffModel
	 *            diff model generated by EMF Compare
	 * @throws IOException
	 */
	private void saveDiff(File targetFile, MatchModel matchModel,
			DiffModel diffModel) throws IOException {
		final ComparisonResourceSnapshot snapshot = DiffFactory.eINSTANCE
				.createComparisonResourceSnapshot();
		snapshot.setDate(Calendar.getInstance().getTime());
		snapshot.setMatch(matchModel);
		snapshot.setDiff(diffModel);

		Resource newModelRes = (new ResourceSetImpl()).createResource(URI
				.createFileURI(targetFile.getPath()));
		newModelRes.getContents().add(snapshot);
		final Map<String, String> options = new EMFCompareMap<String, String>();
		options.put(XMLResource.OPTION_ENCODING,
				System.getProperty("file.encoding"));
		newModelRes.save(options);
	}
}
