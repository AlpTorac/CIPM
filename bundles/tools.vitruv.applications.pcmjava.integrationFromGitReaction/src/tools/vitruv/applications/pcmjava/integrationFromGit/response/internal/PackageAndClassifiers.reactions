import org.eclipse.emf.ecore.util.EcoreUtil

import edu.kit.ipd.sdq.commons.util.org.eclipse.emf.common.util.URIUtil

import org.emftext.language.java.members.Method
import org.emftext.language.java.members.Field
import org.emftext.language.java.classifiers.Class
import org.emftext.language.java.containers.ContainersPackage
import org.emftext.language.java.types.ClassifierReference
import org.emftext.language.java.types.NamespaceClassifierReference
import org.emftext.language.java.modifiers.Public
import org.emftext.language.java.modifiers.Private
import org.emftext.language.java.modifiers.Protected

import org.palladiosimulator.pcm.repository.OperationSignature
import org.palladiosimulator.pcm.repository.RepositoryFactory
import org.palladiosimulator.pcm.repository.Repository
import org.palladiosimulator.pcm.repository.DataType
import org.palladiosimulator.pcm.repository.RepositoryPackage
import org.palladiosimulator.pcm.system.SystemPackage
import org.palladiosimulator.pcm.repository.OperationInterface
import org.palladiosimulator.pcm.repository.CompositeDataType
import org.palladiosimulator.pcm.repository.CollectionDataType
import org.palladiosimulator.pcm.core.entity.Entity

import tools.vitruv.applications.pcmjava.pojotransformations.java2pcm.Java2PcmUserSelection

import tools.vitruv.framework.^correspondence.CorrespondenceModelUtil
import tools.vitruv.applications.pcmjava.util.java2pcm.TypeReferenceCorrespondenceHelper
import tools.vitruv.framework.userinteraction.UserInteractionOptions.WindowModality

import com.google.common.collect.Lists
//import com.google.common.collect.Sets
import java.util.HashMap

import static extension tools.vitruv.applications.util.temporary.java.JavaMemberAndParameterUtil.hasSameSignature
import static extension edu.kit.ipd.sdq.commons.util.java.lang.IterableUtil.claimNotMany
import static tools.vitruv.applications.util.temporary.java.JavaTypeUtil.*
import static tools.vitruv.applications.util.temporary.java.JavaContainerAndClassifierUtil.*
import static tools.vitruv.domains.java.util.JavaPersistenceHelper.*
import org.eclipse.jdt.internal.formatter.old.CodeFormatter

import "http://www.emftext.org/java" as java
import "http://palladiosimulator.org/PalladioComponentModel/5.2" as pcm


reactions: packageAndClassifiers
in reaction to changes in AdjustedJava
execute actions in PCM


//empty implementation for add and remove imports
//reaction AddImportReaction {
//	after element java::Import inserted in java::JavaRoot[imports]
//	call {}
//}
//
//reaction RemoveImportReaction {
//	after element java::Import removed from java::JavaRoot[imports]
//	call {}
//}

//empty implementation for add and remove class annotation
reaction AddClassAnnotationReaction {
	after element inserted in java::Class[annotationsAndModifiers]
	call {}
}

reaction RemoveClassAnnotationReaction {
	after element removed from java::Class[annotationsAndModifiers]
	call {}
}


//Create Interface Method:
reaction InterfaceMethodCreated {
	after element java::InterfaceMethod inserted in java::Interface[members] 
	call createPCMSignature(newValue)
}

routine createPCMSignature(java::InterfaceMethod interfaceMethod) {
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to interfaceMethod.containingConcreteClassifier
	}
	action {
		val operationSignature = create pcm::OperationSignature and initialize {
			operationSignature.entityName = interfaceMethod.name
			operationSignature.interface__OperationSignature = pcmInterface
		}
		
		update pcmInterface {
			pcmInterface.signatures__OperationInterface += operationSignature
		}
		
		add correspondence between operationSignature and interfaceMethod
	}
}


//Create Class Method:
reaction ClassMethodCreated {
	after element java::ClassMethod inserted in java::Class[members]
	call createSeffFromImplementingInterfaces(newValue, affectedEObject)
}

routine createSeffFromImplementingInterfaces(java::ClassMethod classMethod, java::Class javaClass) {
	action {
		call {
			val implementingInterfaces = findImplementingInterfacesFromTypeRefs(javaClass.implements)
			for (implementingInterface : implementingInterfaces) {
				createSeffFromImplementingInterface(classMethod, javaClass, implementingInterface)
			}
		}
	}
}

routine createSeffFromImplementingInterface(java::ClassMethod classMethod, java::Class javaClass, java::Interface javaInterface) {
	match {
		val operationInterface = retrieve pcm::OperationInterface corresponding to javaInterface
	} 
	action {
		call {
			val methods = javaInterface.methods.filter[hasSameSignature(classMethod)]
			for (method : methods) {
				createSEFF(method, javaClass, classMethod)
			}
		}
	}
}

routine createSEFF(java::Method javaMethod, java::Class javaClass, java::ClassMethod classMethod) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to javaMethod
		val basicComponent = retrieve pcm::BasicComponent corresponding to javaClass
	}
	action {
		val rdseff = create pcm::ResourceDemandingSEFF and initialize {
			rdseff.describedService__SEFF = operationSignature
			rdseff.basicComponent_ServiceEffectSpecification = basicComponent
		}
		add correspondence between classMethod and rdseff
		
		update basicComponent {
			basicComponent.serviceEffectSpecifications__BasicComponent += rdseff
		}
	}
}

//Remove Interface Method
reaction RemoveInterfaceMethodEvent {
	after element java::InterfaceMethod removed from java::Interface[members] 
	call removedInterfaceMethodEvent(oldValue)
} 

routine removedInterfaceMethodEvent(java::InterfaceMethod interfaceMethod) {
	match {
		val operationSignature = retrieve pcm::OperationSignature corresponding to interfaceMethod
		//val opSig = retrieve pcm::OperationSignature corresponding to interfaceMethod
	}
	action {
		//'remove correspondence between' is not needed, because 'delete' automatically removes the object and its correspondences 	
		//Should the correspoding SEFFs still exist?
		//Should the references to the removed OperationSignature in all rdseff.describedService__SEFF also be removed?
		delete operationSignature
	}
}


//Remove Class Method
reaction RemoveClassMethodEvent {
	after element java::ClassMethod removed from java::Class[members]
	call removedClassMethodEvent(oldValue)
} 

routine removedClassMethodEvent(java::ClassMethod classMethod) {
	match {
		//val operationSignature = retrieve pcm::OperationSignature corresponding to classMethod
		val seff = retrieve pcm::ResourceDemandingSEFF corresponding to classMethod
	}
	action {
		delete seff
	}
}

//Create Class
reaction ClassCreated {
	after element java::Class inserted in java::CompilationUnit[classifiers]
	call {
		createOrFindArchitecturalElement(newValue)
		decideInterfaceCreation(newValue)
	}
}

/**
 * Creates a new architectural element and add correspondence.
 */
routine createElement(java::Class javaClass, java::Package javaPackage, java::CompilationUnit compilationUnit) {
	match {
		require absence of pcm::DataType corresponding to javaClass
	}
	action {
		call { 
						
		}
	}
}

/**
 * 
 * User can select if he wants to create BasicComponent, CompositeComponent, or do nothing.
 */
routine createOrFindArchitecturalElement(java::ConcreteClassifier javaPackage) {
	match {
		require absence of pcm::RepositoryComponent corresponding to javaPackage
	}
	action {
		call {
			val String userMsg = "A classifier (" + javaPackage.qualifiedName + ") has been created. Please decide whether and which corresponding architectural element should be created."
			val String[] selections = #[Java2PcmUserSelection.SELECT_BASIC_COMPONENT.message,
				Java2PcmUserSelection.SELECT_COMPOSITE_COMPONENT.message,
				Java2PcmUserSelection.SELECT_NOTHING_DECIDE_LATER.message
			]
			val selected = userInteractor.singleSelectionDialogBuilder.message(userMsg).choices(selections)
				.windowModality(WindowModality.MODAL).startInteraction()
			if (selected == Java2PcmUserSelection.SELECT_NOTHING_DECIDE_LATER) {
				return
			}
			val comName = userInteractor.textInputDialogBuilder.message("Please enter the name for the component of " + javaPackage.qualifiedName)
				.windowModality(WindowModality.MODAL).startInteraction
			switch(selected) {
				case Java2PcmUserSelection.SELECT_BASIC_COMPONENT.selection: 
					createOrFindBasicComponent(javaPackage, comName) 
//				case Java2PcmUserSelection.SELECT_COMPOSITE_COMPONENT.selection: 
//					createCompositeComponent(javaPackage, name, rootPackageName)
			}
		}
	}
}

//Create Interface
reaction InterfaceCreated {
	after element java::Interface inserted in java::CompilationUnit[classifiers]
	call {
		createOrFindArchitecturalElement(newValue)
		decideInterfaceCreation(newValue)
	}
}

routine decideInterfaceCreation(java::ConcreteClassifier javaInterface) {
	action {
		call {
			val String userMsg = "Should an architectural interface be created for the classifier " +
					javaInterface.name + " ?"
			val String[] selections = #[Java2PcmUserSelection.SELECT_CREATE_INTERFACE_NOT_IN_CONTRACTS.message,
				Java2PcmUserSelection.SELECT_DONT_CREATE_INTERFACE_NOT_IN_CONTRACTS.message
			]
			val selected = userInteractor.singleSelectionDialogBuilder.message(userMsg).choices(selections)
				.windowModality(WindowModality.MODAL).startInteraction()
			if (selected == Java2PcmUserSelection.SELECT_CREATE_INTERFACE_NOT_IN_CONTRACTS.selection) {
				createInterface(javaInterface)
			}
		}
	}
}

routine createInterface(java::ConcreteClassifier javaInterface) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		val pcmInterface = create pcm::OperationInterface and initialize {
			pcmInterface.entityName = javaInterface.name
		}
		update pcmRepository {
			pcmRepository.interfaces__Repository += pcmInterface
		}
		add correspondence between pcmInterface and javaInterface
	}
}

//Remove Class
reaction RemoveClassEvent {
	after element java::Class removed from java::CompilationUnit[classifiers]
	call {
//		removedClassEvent(oldValue)
	}
} 

routine removedClassEvent(java::Class clazz) {
	match {
		val pcmComponent = retrieve pcm::RepositoryComponent corresponding to clazz
	}
	action {
		delete pcmComponent
	}
}

//Remove Interface
reaction RemoveInterfaceEvent {
	after element java::Interface removed from java::CompilationUnit[classifiers]
	call {
//		removedInterfaceEvent(oldValue)
	}
} 

routine removedInterfaceEvent(java::Interface interfaze) {
	match {
		val pcmComponent = retrieve pcm::RepositoryComponent corresponding to interfaze
	}
	action {
		delete pcmComponent
	}
}

routine createOrFindArchitecturalElementInPackage(java::Package javaPackage, java::Package containingPackage, String rootPackageName) {
	match {
		require absence of pcm::RepositoryComponent corresponding to javaPackage
		val pcmRepository = retrieve pcm::Repository corresponding to ContainersPackage.Literals.PACKAGE
	}
	action {
		
		call {
//			val pcmRepository = correspondenceModel.getAllEObjectsOfTypeInCorrespondences(typeof(Repository)).toList.get(0)
			val pcmComponentCandidate = pcmRepository.components__Repository.findFirst[entityName == javaPackage.name.toFirstUpper]
			if (pcmComponentCandidate === null) {
//				createArchitecturalElement(javaPackage, containingPackage.name, rootPackageName)
			} else {
//				addCorrespondenceAndUpdateRepository(pcmComponentCandidate, javaPackage, pcmRepository)
			}
		}
	}
}

//Add implements
reaction TypeReferenceCreated {
	after element java::TypeReference inserted in java::Class[implements]
		with newValue instanceof NamespaceClassifierReference || newValue instanceof ClassifierReference
	call {
		createOperationProvidedRole(newValue)
	}
}

routine createOperationProvidedRole(java::TypeReference typeReference) {
	action {
		call {
			val javaClass = typeReference.eContainer as Class
			var javaInterfaceClassifier = getNormalizedClassifierFromTypeReference(typeReference)
			createOperationProvidedRoleFromTypeReference(javaInterfaceClassifier, javaClass, typeReference)
		}
	}
}

routine createOperationProvidedRoleFromTypeReference(java::Classifier classifierInterface, java::Class javaClass, java::TypeReference reference) {
	match {
		val opInterface = retrieve pcm::OperationInterface corresponding to classifierInterface
		val basicComponent = retrieve pcm::BasicComponent corresponding to javaClass
	}
	action {
		val operationProvidedRole = create pcm::OperationProvidedRole and initialize {
			operationProvidedRole.providedInterface__OperationProvidedRole = opInterface
			operationProvidedRole.providingEntity_ProvidedRole = basicComponent
			operationProvidedRole.entityName = basicComponent.entityName + "_provides_" + opInterface.entityName
		}
		add correspondence between operationProvidedRole and reference
	}
}

//Remove implements
reaction TypeReferenceRemoved {
	after element java::TypeReference removed from java::Class[implements]
	with oldValue instanceof NamespaceClassifierReference || oldValue instanceof ClassifierReference
	call {
		removeOperationProvidedRole(oldValue)	
	}
}

routine removeOperationProvidedRole(java::TypeReference typeReference) {
	match {
		val operationProvidedRole = retrieve pcm::OperationProvidedRole corresponding to typeReference
	}
	
	action {
		delete operationProvidedRole
	}
}

routine createOrFindBasicComponent(java::ConcreteClassifier javaPackage, String name) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		call {
			val pcmBasicComponent = pcmRepository.components__Repository.findFirst[it.entityName == name]
			if (pcmBasicComponent !== null) {
				addCorrespondenceAndUpdateRepository(pcmBasicComponent, javaPackage)
				return
			}	
		}
		val pcmBasicComponent = create pcm::BasicComponent and initialize {
			pcmBasicComponent.entityName = name
		}
		call {
			addCorrespondenceAndUpdateRepository(pcmBasicComponent, javaPackage)
		}
	}
}

routine createCompositeComponent(java::Package javaPackage, String name, String rootPackageName) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		val pcmCompositeComponent = create pcm::CompositeComponent and initialize {
			pcmCompositeComponent.entityName = name
		}		
		call {
//			addCorrespondenceAndUpdateRepository(pcmCompositeComponent, javaPackage, pcmRepository)
		}
	}
}

/**
 * Adds a correspondence between a component and a classifier if the correspondence does not already exists, and adds the component to the repository.
 */
routine addCorrespondenceAndUpdateRepository(pcm::RepositoryComponent pcmComponent, java::ConcreteClassifier javaPackage) {
	match {
		val correspondingElement = retrieve optional pcm::RepositoryComponent corresponding to javaPackage
		val pcmRepository = retrieve pcm::Repository corresponding to RepositoryPackage.Literals.REPOSITORY
	}
	action {
		update pcmRepository {
			if(!pcmRepository.components__Repository.contains(pcmComponent)) {
				pcmRepository.components__Repository += pcmComponent
			}
		}
		call {
			if(!correspondingElement.isPresent) {
				addCorrespondenceForPcmComponent(pcmComponent, javaPackage)
			}
		}
	}
}

routine addCorrespondenceForPcmComponent(pcm::RepositoryComponent pcmComponent, java::Commentable javaElement) {
	action {
		add correspondence between pcmComponent and javaElement
	}
}

routine renameComponent(java::Package javaPackage) {
	match {
		val pcmComponent = retrieve pcm::RepositoryComponent corresponding to javaPackage
	}
	action {
		update pcmComponent {
			pcmComponent.entityName = javaPackage.name.toFirstUpper;
		}
	}
}

reaction JavaInterfaceRenamed {
	after attribute replaced at java::Interface[name]
	call {
		renameInterface(affectedEObject)
	}
}

routine renameInterface(java::ConcreteClassifier javaInterface) {
	match {
		val pcmInterface = retrieve pcm::OperationInterface corresponding to javaInterface}
	action {
		update pcmInterface {
			pcmInterface.entityName = javaInterface.name
		}
	}
}

//Class
reaction JavaClassRenamed {
	after attribute replaced at java::Class[name]
	call {
//		renameComponentFromClass(affectedEObject)
		renameDataTypeFromClass(affectedEObject)
		renameInterface(affectedEObject)
	}
}

routine renameComponentFromClass(java::Class javaClass) {
	match {
		val pcmComponent = retrieve pcm::RepositoryComponent corresponding to javaClass
	}
	action {
		update pcmComponent {
			var newName = javaClass.name.toFirstUpper
			if (newName.endsWith("Impl")) newName = newName.substring(0, newName.length - "Impl".length)
			pcmComponent.entityName = newName
		}
	}
}

routine renameDataTypeFromClass(java::Class javaClass) {
	match {
		val dataType = retrieve pcm::DataType corresponding to javaClass
	}
	action {
		update dataType {
			if(dataType instanceof Entity) { // primitive data types don't have names
				dataType.entityName = javaClass.name.toFirstUpper
			}
		}
	}
}

/**
 * User can choose if a composite or collection data type should be created.
 */
routine createDataType(java::Class javaClass, java::CompilationUnit compilationUnit) {
	action {
		call {
			val String userMsg = "Class " + javaClass.name +
						" has been created in the datatypes package. Please decide which kind of data type should be created."
			val String[] selections = #[Java2PcmUserSelection.SELECT_COMPOSITE_DATA_TYPE.message,
				Java2PcmUserSelection.SELECT_COLLECTION_DATA_TYPE.message,
				Java2PcmUserSelection.SELECT_NOTHING_DECIDE_LATER.message
			]
			val selected = userInteractor.singleSelectionDialogBuilder.message(userMsg).choices(selections)
				.windowModality(WindowModality.MODAL).startInteraction()
			switch(selected) {
				case Java2PcmUserSelection.SELECT_COMPOSITE_DATA_TYPE.selection: 
					createOrFindCompositeDataType(javaClass, compilationUnit)
				case Java2PcmUserSelection.SELECT_COLLECTION_DATA_TYPE.selection: 
					createOrFindCollectionDataType(javaClass, compilationUnit)
			}
		}
	}
}

routine createOrFindCompositeDataType(java::Class javaClass, java::CompilationUnit compilationUnit) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to ContainersPackage.Literals.PACKAGE
	}
	action {
		call {
			val foundCompositeDataType = pcmRepository.dataTypes__Repository.filter(CompositeDataType)
				.filter[entityName.toFirstUpper == javaClass.name.toFirstUpper || javaClass.name === null && entityName == "aName"].claimNotMany
			if (foundCompositeDataType === null) {
				createCompositeDataType(javaClass, compilationUnit)
			} else {
				addDataTypeCorrespondence(javaClass, compilationUnit, foundCompositeDataType)
			}
		}
	}
}

routine createCompositeDataType(java::Class javaClass, java::CompilationUnit compilationUnit) {
	action {
		val pcmCompositeDataType = create pcm::CompositeDataType and initialize {
			pcmCompositeDataType.entityName = javaClass.name
		}
		add correspondence between pcmCompositeDataType and javaClass
		call {
			addDataTypeCorrespondence(javaClass, compilationUnit, pcmCompositeDataType)
			addDataTypeInRepository(pcmCompositeDataType)
		}
	}
}

routine createOrFindCollectionDataType(java::Class javaClass, java::CompilationUnit compilationUnit) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to ContainersPackage.Literals.PACKAGE
	}
	action {
		call {
			val foundCollectionDataType = pcmRepository.dataTypes__Repository.filter(CollectionDataType)
				.filter[entityName.toFirstUpper == javaClass.name.toFirstUpper || javaClass.name === null && entityName == "aName"].claimNotMany
			if (foundCollectionDataType === null) {
				createCollectionDataType(javaClass, compilationUnit)
			} else {
				addDataTypeCorrespondence(javaClass, compilationUnit, foundCollectionDataType)
			}
		}
	}
}

routine createCollectionDataType(java::Class javaClass, java::CompilationUnit compilationUnit) {
	action {
		val pcmCollectionDataType = create pcm::CollectionDataType and initialize {
			pcmCollectionDataType.entityName = javaClass.name
		}
		call {
			addDataTypeCorrespondence(javaClass, compilationUnit, pcmCollectionDataType)
			addDataTypeInRepository(pcmCollectionDataType)
		}
	}
}

routine addDataTypeCorrespondence(java::Class javaClass, java::CompilationUnit compilationUnit, pcm::DataType dataType) {
	action {
		add correspondence between dataType and javaClass
		add correspondence between compilationUnit and javaClass
	}
}

routine addDataTypeInRepository(pcm::DataType pcmDataType) {
	match {
		val pcmRepository = retrieve pcm::Repository corresponding to ContainersPackage.Literals.PACKAGE
	}
	action {
		update pcmDataType {
			pcmDataType.repository__DataType = pcmRepository
		}
		update pcmRepository {
			pcmRepository.dataTypes__Repository += pcmDataType
		}
	}
}
