package cipm.consistency.fitests.similarity.params;

import java.util.ArrayList;
import java.util.Collection;
import java.util.function.Predicate;

import cipm.consistency.initialisers.IInitialiser;
import cipm.consistency.initialisers.IInitialiserBase;
import cipm.consistency.initialisers.IInitialiserPackage;

/**
 * An interface meant for classes that generate {@link IInitialiser} instances
 * for tests. <br>
 * <br>
 * Implementors of this interface can be used to supply parameterized tests with
 * {@link IInitialiser} instances (via
 * {@link #getAdaptedInitialisersBySuper(Class)}), since it allows adapting the
 * {@link IInitialiser} instances. That way, those instances can be augmented to
 * conform the needs of such tests, if any.
 */
public interface IInitialiserParameters {
	/**
	 * @return The {@link IInitialiserPackage} that will be used to generate
	 *         {@link IInitialiser} parameters for tests.
	 */
	public IInitialiserPackage getUsedInitialiserPackage();

	/**
	 * @return An instance of all {@link IInitialiser}s the
	 *         {@link IInitialiserParameters} encompasses. The returned
	 *         {@link IInitialiser}s are not adapted.
	 */
	public default Collection<IInitialiser> getAllNonAdaptedInitialisers() {
		return this.getUsedInitialiserPackage().getAllInitialiserInstances();
	}

	/**
	 * @return An adapted instance of all initialisers this encompasses. Adaptation
	 *         logic returned by {@link #getAdaptationStrategy()} is used to adapt
	 *         the generated initialiser instances.
	 */
	public default Collection<IInitialiserBase> getAllAdaptedInitialisers() {
		var result = new ArrayList<IInitialiserBase>();
		var res = this.getAllNonAdaptedInitialisers();

		if (res != null) {
			res.stream().filter((init) -> !IInitialiserBase.class.isAssignableFrom(init.getClass()))
					.forEach((init) -> result.add((IInitialiserBase) init));

			this.adaptInitialisers(result);
		}

		return result;
	}

	/**
	 * Shortcut for {@link #getAllNonAdaptedInitialisers()} and
	 * {@link #getAllAdaptedInitialisers()}.
	 */
	public default Collection<IInitialiser> getAllInitialisers() {
		var result = new ArrayList<IInitialiser>();
		result.addAll(this.getAllNonAdaptedInitialisers());
		result.addAll(this.getAllAdaptedInitialisers());
		return result;
	}

	/**
	 * @return The {@link IInitialiserParameterAdaptationStrategy} responsible for
	 *         altering the generated initialisers for
	 *         {@link #getAdaptedInitialisersBySuper(Class)}.
	 */
	public IInitialiserParameterAdaptationStrategy getAdaptationStrategy();

	public default Collection<IInitialiser> getNonAdaptedInitialisersBy(Predicate<IInitialiser> pred) {
		var result = new ArrayList<IInitialiser>();
		this.getAllNonAdaptedInitialisers().stream().filter(pred).forEach((i) -> result.add(i));
		return result;
	}

	public default Collection<IInitialiserBase> getAdaptedInitialisersBy(Predicate<IInitialiserBase> pred) {
		var result = new ArrayList<IInitialiserBase>();
		this.getAllAdaptedInitialisers().stream().filter(pred).forEach((i) -> result.add(i));
		return result;
	}

	/**
	 * @return All {@link IInitialiser} instances generated by
	 *         {@link #getAllNonAdaptedInitialisers()} that extend the given class.
	 */
	@SuppressWarnings("unchecked")
	public default <T extends IInitialiser> Collection<T> getNonAdaptedInitialisersBySuper(Class<T> cls) {
		return (Collection<T>) this.getNonAdaptedInitialisersBy((i) -> cls.isInstance(i));
	}

	/**
	 * @return Adapted versions of all {@link IInitialiser} instances generated by
	 *         {@link #getAllNonAdaptedInitialisers()} that extend the given class.
	 */
	@SuppressWarnings("unchecked")
	public default <T extends IInitialiserBase> Collection<T> getAdaptedInitialisersBySuper(Class<T> cls) {
		var res = this.getAdaptedInitialisersBy((i) -> cls.isInstance(i));

		this.adaptInitialisers(res);
		return (Collection<T>) res;
	}

	/**
	 * @return All {@link IInitialiser} instances generated by
	 *         {@link #getAllAdaptedInitialisers()} that extend the given class.
	 */
	@SuppressWarnings("unchecked")
	public default <T extends IInitialiser> Collection<T> getAllInitialisersBySuper(Class<T> cls) {
		var result = new ArrayList<T>();
		this.getAllInitialisers().stream().filter((init) -> cls.isInstance(init))
				.forEach((init) -> result.add((T) init));

		return result;
	}

	/**
	 * @return An instance of each {@link IInitialiser} from
	 *         {@link #getAllNonAdaptedInitialisers()}. Use this method, if only one
	 *         instance init of each initialiser is desired. If
	 *         {@link #getAdaptationStrategy()} can adapt init, it will do so.
	 */
	public default Collection<IInitialiser> getEachInitialiserOnce() {
		var result = this.getAllNonAdaptedInitialisers();
		this.adaptInitialisers(result);
		return result;
	}
	
	/**
	 * @return An instance of each {@link IInitialiser} from
	 *         {@link #getAllNonAdaptedInitialisers()}. Use this method, if only one
	 *         instance init of each initialiser is desired. If
	 *         {@link #getAdaptationStrategy()} can adapt init, it will do so.
	 */
	@SuppressWarnings("unchecked")
	public default <T extends IInitialiser> Collection<T> getEachInitialiserOnceBySuper(Class<T> cls) {
		var result = new ArrayList<T>();
		this.getEachInitialiserOnce().stream().filter((init) -> cls.isInstance(init)).forEach((init) -> result.add((T) init));
		
		return result;
	}

	/**
	 * Applies the adaptation logic encapsulated by
	 * {@link IInitialiserParameterAdaptationStrategy} returned by
	 * {@link #getAdaptationStrategy()}.
	 */
	public default <T extends IInitialiser> void adaptInitialisers(Collection<T> inits) {
		var strat = this.getAdaptationStrategy();

		if (strat != null) {
			strat.adaptInitialisers(inits);
		}
	}
}
